{"version":3,"sources":["webpack:///./src/lib/id3/remote-reader.ts","webpack:///./src/lib/id3/reader.ts","webpack:///./src/lib/id3/genres.ts","webpack:///./src/lib/id3/utils.ts","webpack:///./src/lib/id3/id3-frame.ts","webpack:///./src/lib/id3/id3-tag.ts","webpack:///./src/lib/id3/index.ts","webpack:///./node_modules/gatsby/node_modules/core-js/modules/es6.typed.uint16-array.js"],"names":["RemoteReader","url","Error","open","a","fetch","this","method","resp","len","headers","get","size","Number","read","pos","Range","then","res","arrayBuffer","close","readBlob","type","data","Blob","genres","getString","view","length","offset","raw","byteLength","limit","i","cur","getUint8","push","str","map","char","String","fromCharCode","join","decodeURIComponent","getStringUtf16","bom","littleEndian","getUint16","ch","Array","from","Uint16Array","getSynch","num","out","mask","getUint32Synch","getUint32","getUint24","types","Map","imageTypes","parse","buffer","major","minor","result","id","tag","value","dv","DataView","header","matchedType","val","parseInt","indexOf","substr","image","mime","toLowerCase","description","variableLength","slice","variableStart","parseLegacy","flags","encoding","identifier","handle","v1HeaderBuf","v1Header","undefined","kind","title","trim","album","artist","year","genre","comment","track","version","v2PrefixBuf","v2Prefix","headerSize","tagSize","tagFlags","frames","images","v2TagBuf","v2Tag","position","isFrame","frameBit","parseFrame","frame","tagAsV2","fromReader","reader","tags","load","init","byteOffset"],"mappings":"grBAEqBA,E,oBAEnB,WAAYC,GAAa,MAEvB,GADA,sBACKA,EAAK,MAAM,IAAIC,MAAM,mBAFH,OAGvB,EAAKD,IAAMA,EAHY,E,kHAKnBE,K,6BAAN,8BAAAC,EAAA,sEACqBC,MAAMC,KAAKL,IAAK,CAAEM,OAAQ,SAD/C,OACQC,EADR,OAEQC,EAAMD,EAAKE,QAAQC,IAAI,kBAC7BL,KAAKM,KAAOH,EAAMI,OAAOJ,GAAO,EAHlC,gD,uDAKMK,K,6BAAN,WAAWL,EAAKM,GAAhB,SAAAX,EAAA,sEACeC,MAAMC,KAAKL,IAAK,CAC3BM,OAAQ,MACRG,QAAS,CACPM,MAAO,SAASD,EAAX,KAAkBA,EAAMN,EAAM,MAEpCQ,MAAK,SAAAC,GAAG,OAAIA,EAAIC,iBANrB,wF,0DAQMC,M,6BAAN,sBAAAhB,EAAA,0F,qFCpBAQ,KAAe,E,mBAOTS,S,gCAAN,WAAeZ,EAAaM,EAASO,GAArC,eAAAlB,EAAA,sEAA4BW,MAAM,QAAlC,IAAqCO,MAAO,4BAA5C,SACqBhB,KAAKQ,KAAKL,EAAKM,GADpC,cACQQ,EADR,yBAES,IAAIC,KAAK,CAACD,GAAO,CAAED,UAF5B,+C,+OC+IaG,G,kDAxJA,CACb,QACA,eACA,UACA,QACA,QACA,OACA,SACA,UACA,OACA,QACA,UACA,SACA,QACA,MACA,MACA,MACA,SACA,OACA,SACA,aACA,cACA,MACA,cACA,SACA,aACA,cACA,UACA,WACA,QACA,YACA,SACA,SACA,YACA,eACA,OACA,QACA,OACA,aACA,SACA,QACA,aACA,OACA,OACA,OACA,QACA,aACA,mBACA,oBACA,SACA,SACA,WACA,oBACA,aACA,WACA,YACA,QACA,gBACA,SACA,OACA,cACA,SACA,gBACA,aACA,SACA,kBACA,UACA,WACA,cACA,OACA,YACA,UACA,QACA,SACA,YACA,YACA,QACA,QACA,UACA,cACA,YACA,OACA,YACA,gBACA,QACA,eACA,QACA,QACA,UACA,SACA,YACA,aACA,cACA,mBACA,mBACA,iBACA,YACA,WACA,SACA,iBACA,WACA,SACA,SACA,UACA,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","file":"20-2ab85fe96d8c405a0ea5.js","sourcesContent":["import Reader from '@/lib/id3/reader'\r\n\r\nexport default class RemoteReader extends Reader {\r\n  private readonly url: string\r\n  constructor(url: string) {\r\n    super()\r\n    if (!url) throw new Error('url is required')\r\n    this.url = url\r\n  }\r\n  async open() {\r\n    const resp = await fetch(this.url, { method: 'HEAD' })\r\n    const len = resp.headers.get('Content-Length')\r\n    this.size = len ? Number(len) : 0\r\n  }\r\n  async read(len, pos) {\r\n    return await fetch(this.url, {\r\n      method: 'GET',\r\n      headers: {\r\n        Range: `bytes=${pos}-${pos + len - 1}`\r\n      }\r\n    }).then(res => res.arrayBuffer())\r\n  }\r\n  async close() {\r\n    // waiting...\r\n  }\r\n}\r\n","export default abstract class Reader {\r\n  // Size of resource\r\n  size: number = 0\r\n  // Open the resource for reading\r\n  abstract async open(): Promise<void>\r\n  // Closes the resource\r\n  abstract async close(): Promise<void>\r\n  // Reads a specified range of the resource\r\n  abstract async read(len: number, pos: number): Promise<ArrayBuffer>\r\n  async readBlob(len: number, pos = 0, type = 'application/octet-stream') {\r\n    const data = await this.read(len, pos)\r\n    return new Blob([data], { type })\r\n  }\r\n}\r\n","const genres = [\r\n  'Blues',\r\n  'Classic Rock',\r\n  'Country',\r\n  'Dance',\r\n  'Disco',\r\n  'Funk',\r\n  'Grunge',\r\n  'Hip-Hop',\r\n  'Jazz',\r\n  'Metal',\r\n  'New Age',\r\n  'Oldies',\r\n  'Other',\r\n  'Pop',\r\n  'R&B',\r\n  'Rap',\r\n  'Reggae',\r\n  'Rock',\r\n  'Techno',\r\n  'Industrial',\r\n  'Alternative',\r\n  'Ska',\r\n  'Death Metal',\r\n  'Pranks',\r\n  'Soundtrack',\r\n  'Euro-Techno',\r\n  'Ambient',\r\n  'Trip-Hop',\r\n  'Vocal',\r\n  'Jazz+Funk',\r\n  'Fusion',\r\n  'Trance',\r\n  'Classical',\r\n  'Instrumental',\r\n  'Acid',\r\n  'House',\r\n  'Game',\r\n  'Sound Clip',\r\n  'Gospel',\r\n  'Noise',\r\n  'AlternRock',\r\n  'Bass',\r\n  'Soul',\r\n  'Punk',\r\n  'Space',\r\n  'Meditative',\r\n  'Instrumental Pop',\r\n  'Instrumental Rock',\r\n  'Ethnic',\r\n  'Gothic',\r\n  'Darkwave',\r\n  'Techno-Industrial',\r\n  'Electronic',\r\n  'Pop-Folk',\r\n  'Eurodance',\r\n  'Dream',\r\n  'Southern Rock',\r\n  'Comedy',\r\n  'Cult',\r\n  'Gangsta Rap',\r\n  'Top 40',\r\n  'Christian Rap',\r\n  'Pop / Funk',\r\n  'Jungle',\r\n  'Native American',\r\n  'Cabaret',\r\n  'New Wave',\r\n  'Psychedelic',\r\n  'Rave',\r\n  'Showtunes',\r\n  'Trailer',\r\n  'Lo-Fi',\r\n  'Tribal',\r\n  'Acid Punk',\r\n  'Acid Jazz',\r\n  'Polka',\r\n  'Retro',\r\n  'Musical',\r\n  'Rock & Roll',\r\n  'Hard Rock',\r\n  'Folk',\r\n  'Folk-Rock',\r\n  'National Folk',\r\n  'Swing',\r\n  'Fast  Fusion',\r\n  'Bebob',\r\n  'Latin',\r\n  'Revival',\r\n  'Celtic',\r\n  'Bluegrass',\r\n  'Avantgarde',\r\n  'Gothic Rock',\r\n  'Progressive Rock',\r\n  'Psychedelic Rock',\r\n  'Symphonic Rock',\r\n  'Slow Rock',\r\n  'Big Band',\r\n  'Chorus',\r\n  'Easy Listening',\r\n  'Acoustic',\r\n  'Humour',\r\n  'Speech',\r\n  'Chanson',\r\n  'Opera',\r\n  'Chamber Music',\r\n  'Sonata',\r\n  'Symphony',\r\n  'Booty Bass',\r\n  'Primus',\r\n  'Porn Groove',\r\n  'Satire',\r\n  'Slow Jam',\r\n  'Club',\r\n  'Tango',\r\n  'Samba',\r\n  'Folklore',\r\n  'Ballad',\r\n  'Power Ballad',\r\n  'Rhythmic Soul',\r\n  'Freestyle',\r\n  'Duet',\r\n  'Punk Rock',\r\n  'Drum Solo',\r\n  'A Cappella',\r\n  'Euro-House',\r\n  'Dance Hall',\r\n  'Goa',\r\n  'Drum & Bass',\r\n  'Club-House',\r\n  'Hardcore',\r\n  'Terror',\r\n  'Indie',\r\n  'BritPop',\r\n  'Negerpunk',\r\n  'Polsk Punk',\r\n  'Beat',\r\n  'Christian Gangsta Rap',\r\n  'Heavy Metal',\r\n  'Black Metal',\r\n  'Crossover',\r\n  'Contemporary Christian',\r\n  'Christian Rock',\r\n  'Merengue',\r\n  'Salsa',\r\n  'Thrash Metal',\r\n  'Anime',\r\n  'JPop',\r\n  'Synthpop',\r\n  'Rock/Pop'\r\n];\r\n\r\nexport default genres;\r\n","/**\r\n * Retrieves a string from a specific offset of a data view\r\n * @param {DataView} view View to retrieve string from\r\n * @param {number=} length Bytes to read\r\n * @param {number=} offset Offset to read from\r\n * @param {boolean=} raw Whether to return the raw string or not\r\n * @return {string}\r\n */\r\nexport function getString(\r\n  view: DataView,\r\n  length?: number,\r\n  offset = 0,\r\n  raw?: boolean\r\n) {\r\n  let len = length || view.byteLength - offset\r\n  if (len < 0) len += view.byteLength\r\n\r\n  const data: number[] = []\r\n  const limit = offset + len\r\n  for (let i = offset; i < limit; i++) {\r\n    const cur = view.getUint8(i)\r\n    if (cur === 0) break\r\n    data.push(cur)\r\n  }\r\n  const str = data.map(char => String.fromCharCode(char)).join('')\r\n\r\n  if (raw) return str\r\n  return decodeURIComponent(str)\r\n}\r\n\r\n/**\r\n * Retrieves a UTF16 string from a specific offset of a data view\r\n * @param {DataView} view View to retrieve string from\r\n * @param {number|null} length Bytes to read\r\n * @param {number=} offset Offset to read from\r\n * @param {boolean=} bom Whether to use BOM or not\r\n * @return {string}\r\n */\r\nexport function getStringUtf16(\r\n  view: DataView,\r\n  length: number | null,\r\n  offset = 0,\r\n  bom?: boolean\r\n) {\r\n  let littleEndian = false\r\n  let len = length || view.byteLength - offset\r\n  const str: number[] = []\r\n\r\n  if (len < 0) len += view.byteLength\r\n  if (offset + 1 > view.byteLength) return ''\r\n  if (bom) {\r\n    const bomInt = view.getUint16(offset)\r\n    if (bomInt === 0xfffe) {\r\n      littleEndian = true\r\n    }\r\n    offset += 2\r\n    len -= 2\r\n  }\r\n  const limit = offset + len\r\n  for (let i = offset; i < limit; i += 2) {\r\n    let ch = view.getUint16(i, littleEndian)\r\n\r\n    if (\r\n      i < limit - 1 &&\r\n      ch === 0 &&\r\n      view.getUint16(i + 1, littleEndian) === 0\r\n    ) {\r\n      break\r\n    }\r\n\r\n    if ((ch >= 0 && ch <= 0xd7ff) || (ch >= 0xe000 && ch <= 0xffff)) {\r\n      str.push(ch)\r\n    } else if (ch >= 0x10000 && ch <= 0x10ffff) {\r\n      ch -= 0x10000\r\n\r\n      str.push(((0xffc00 & ch) >> 10) + 0xd800)\r\n      str.push((0x3ff & ch) + 0xdc00)\r\n    }\r\n  }\r\n  return Array.from(new Uint16Array(str))\r\n    .map(char => String.fromCharCode(char))\r\n    .join('')\r\n}\r\n\r\n/**\r\n * Gets the \"synch\" representation of a number\r\n * @param {number} num Number to convert\r\n * @return {number}\r\n */\r\nexport function getSynch(num: number): number {\r\n  let out = 0\r\n  let mask = 0x7f000000\r\n\r\n  while (mask) {\r\n    out >>= 1\r\n    out |= num & mask\r\n    mask >>= 8\r\n  }\r\n\r\n  return out\r\n}\r\n\r\n/**\r\n * Gets a \"synch2 uint8 from a view\r\n * @param {DataView} view View to read\r\n * @param {number=} offset Offset to read from\r\n * @return {number}\r\n */\r\nexport function getUint8Synch(view: DataView, offset: number = 0): number {\r\n  return getSynch(view.getUint8(offset))\r\n}\r\n\r\n/**\r\n * Gets a \"synch2 uint32 from a view\r\n * @param {DataView} view View to read\r\n * @param {number=} offset Offset to read from\r\n * @return {number}\r\n */\r\nexport function getUint32Synch(view: DataView, offset: number = 0): number {\r\n  return getSynch(view.getUint32(offset))\r\n}\r\n\r\n/**\r\n * Gets a uint24 from a view\r\n * @param {DataView} view View to read\r\n * @param {number=} offset Offset to read from\r\n * @param {boolean=} littleEndian Whether to use little endian or not\r\n * @return {number}\r\n */\r\nexport function getUint24(\r\n  view: DataView,\r\n  offset = 0,\r\n  littleEndian?: boolean\r\n): number {\r\n  if (littleEndian) {\r\n    return (\r\n      view.getUint8(offset) +\r\n      (view.getUint8(offset + 1) << 8) +\r\n      (view.getUint8(offset + 2) << 16)\r\n    )\r\n  }\r\n  return (\r\n    view.getUint8(offset + 2) +\r\n    (view.getUint8(offset + 1) << 8) +\r\n    (view.getUint8(offset) << 16)\r\n  )\r\n}\r\n","import genres from '@/lib/id3/genres'\r\nimport {\r\n  getString,\r\n  getUint24,\r\n  getUint32Synch,\r\n  getStringUtf16\r\n} from '@/lib/id3/utils'\r\n\r\nexport interface ID3Frame {\r\n  tag: string | null\r\n  value: any\r\n  id: string | null\r\n}\r\n\r\nexport interface ImageValue {\r\n  type: string | null\r\n  mime: string | null\r\n  description: string | null\r\n  data: ArrayBuffer | null\r\n}\r\n\r\nexport const types: ReadonlyMap<string, string> = new Map<string, string>([\r\n  /*\r\n   * Textual frames\r\n   */\r\n  ['TALB', 'album'],\r\n  ['TBPM', 'bpm'],\r\n  ['TCOM', 'composer'],\r\n  ['TCON', 'genre'],\r\n  ['TCOP', 'copyright'],\r\n  ['TDEN', 'encoding-time'],\r\n  ['TDLY', 'playlist-delay'],\r\n  ['TDOR', 'original-release-time'],\r\n  ['TDRC', 'recording-time'],\r\n  ['TDRL', 'release-time'],\r\n  ['TDTG', 'tagging-time'],\r\n  ['TENC', 'encoder'],\r\n  ['TEXT', 'writer'],\r\n  ['TFLT', 'file-type'],\r\n  ['TIPL', 'involved-people'],\r\n  ['TIT1', 'content-group'],\r\n  ['TIT2', 'title'],\r\n  ['TIT3', 'subtitle'],\r\n  ['TKEY', 'initial-key'],\r\n  ['TLAN', 'language'],\r\n  ['TLEN', 'length'],\r\n  ['TMCL', 'credits'],\r\n  ['TMED', 'media-type'],\r\n  ['TMOO', 'mood'],\r\n  ['TOAL', 'original-album'],\r\n  ['TOFN', 'original-filename'],\r\n  ['TOLY', 'original-writer'],\r\n  ['TOPE', 'original-artist'],\r\n  ['TOWN', 'owner'],\r\n  ['TPE1', 'artist'],\r\n  ['TPE2', 'band'],\r\n  ['TPE3', 'conductor'],\r\n  ['TPE4', 'remixer'],\r\n  ['TPOS', 'set-part'],\r\n  ['TPRO', 'produced-notice'],\r\n  ['TPUB', 'publisher'],\r\n  ['TRCK', 'track'],\r\n  ['TRSN', 'radio-name'],\r\n  ['TRSO', 'radio-owner'],\r\n  ['TSOA', 'album-sort'],\r\n  ['TSOP', 'performer-sort'],\r\n  ['TSOT', 'title-sort'],\r\n  ['TSRC', 'isrc'],\r\n  ['TSSE', 'encoder-settings'],\r\n  ['TSST', 'set-subtitle'],\r\n  /*\r\n   * Textual frames (<=2.2)\r\n   */\r\n  ['TAL', 'album'],\r\n  ['TBP', 'bpm'],\r\n  ['TCM', 'composer'],\r\n  ['TCO', 'genre'],\r\n  ['TCR', 'copyright'],\r\n  ['TDY', 'playlist-delay'],\r\n  ['TEN', 'encoder'],\r\n  ['TFT', 'file-type'],\r\n  ['TKE', 'initial-key'],\r\n  ['TLA', 'language'],\r\n  ['TLE', 'length'],\r\n  ['TMT', 'media-type'],\r\n  ['TOA', 'original-artist'],\r\n  ['TOF', 'original-filename'],\r\n  ['TOL', 'original-writer'],\r\n  ['TOT', 'original-album'],\r\n  ['TP1', 'artist'],\r\n  ['TP2', 'band'],\r\n  ['TP3', 'conductor'],\r\n  ['TP4', 'remixer'],\r\n  ['TPA', 'set-part'],\r\n  ['TPB', 'publisher'],\r\n  ['TRC', 'isrc'],\r\n  ['TRK', 'track'],\r\n  ['TSS', 'encoder-settings'],\r\n  ['TT1', 'content-group'],\r\n  ['TT2', 'title'],\r\n  ['TT3', 'subtitle'],\r\n  ['TXT', 'writer'],\r\n  /*\r\n   * URL frames\r\n   */\r\n  ['WCOM', 'url-commercial'],\r\n  ['WCOP', 'url-legal'],\r\n  ['WOAF', 'url-file'],\r\n  ['WOAR', 'url-artist'],\r\n  ['WOAS', 'url-source'],\r\n  ['WORS', 'url-radio'],\r\n  ['WPAY', 'url-payment'],\r\n  ['WPUB', 'url-publisher'],\r\n  /*\r\n   * URL frames (<=2.2)\r\n   */\r\n  ['WAF', 'url-file'],\r\n  ['WAR', 'url-artist'],\r\n  ['WAS', 'url-source'],\r\n  ['WCM', 'url-commercial'],\r\n  ['WCP', 'url-copyright'],\r\n  ['WPB', 'url-publisher'],\r\n  /*\r\n   * Comment frame\r\n   */\r\n  ['COMM', 'comments'],\r\n  /*\r\n   * Image frame\r\n   */\r\n  ['APIC', 'image'],\r\n  ['PIC', 'image'],\r\n  /*\r\n   * Private frames\r\n   */\r\n  ['PRIV', 'private']\r\n])\r\n\r\nexport const imageTypes = [\r\n  'other',\r\n  'file-icon',\r\n  'icon',\r\n  'cover-front',\r\n  'cover-back',\r\n  'leaflet',\r\n  'media',\r\n  'artist-lead',\r\n  'artist',\r\n  'conductor',\r\n  'band',\r\n  'composer',\r\n  'writer',\r\n  'location',\r\n  'during-recording',\r\n  'during-performance',\r\n  'screen',\r\n  'fish',\r\n  'illustration',\r\n  'logo-band',\r\n  'logo-publisher'\r\n]\r\n\r\n/**\r\n * Parses legacy frames for ID3 v2.2 and earlier\r\n * @param {ArrayBuffer} buffer Buffer to read\r\n * @return {ID3Frame|null}\r\n */\r\nexport function parseLegacy(buffer: ArrayBuffer): ID3Frame | null {\r\n  const result: ID3Frame = {\r\n    id: null,\r\n    tag: null,\r\n    value: null\r\n  }\r\n  const dv = new DataView(buffer)\r\n  const header = {\r\n    id: getString(dv, 3),\r\n    type: getString(dv, 1),\r\n    size: getUint24(dv, 3)\r\n  }\r\n\r\n  const matchedType = types.get(header.id)\r\n\r\n  if (!matchedType) {\r\n    return null\r\n  }\r\n\r\n  result.id = header.id\r\n  result.tag = matchedType\r\n\r\n  if (header.type === 'T') {\r\n    /*\r\n     * TODO: Implement UTF-8, UTF-16 and UTF-16 with BOM properly?\r\n     */\r\n    let val = getString(dv, -7, 7)\r\n\r\n    if (header.id === 'TCO' && !!parseInt(val)) {\r\n      val = genres[parseInt(val)]\r\n    }\r\n\r\n    result.value = val\r\n  } else if (header.type === 'W') {\r\n    result.value = getString(dv, -7, 7)\r\n  } else if (header.id === 'COM') {\r\n    /*\r\n     * TODO: Implement UTF-8, UTF-16 and UTF-16 with BOM properly?\r\n     */\r\n    let val = getString(dv, -10, 10)\r\n\r\n    if (val.indexOf('\\x00') !== -1) {\r\n      val = val.substr(val.indexOf('\\x00') + 1)\r\n    }\r\n\r\n    result.value = val\r\n  } else if (header.id === 'PIC') {\r\n    const image: ImageValue = {\r\n      type: null,\r\n      mime: 'image/' + getString(dv, 3, 7).toLowerCase(),\r\n      description: null,\r\n      data: null\r\n    }\r\n\r\n    image.type = imageTypes[dv.getUint8(11)] || 'other'\r\n\r\n    const variableStart = 11\r\n    let variableLength = 0\r\n\r\n    for (let i = variableStart; ; i++) {\r\n      if (dv.getUint8(i) === 0x00) {\r\n        variableLength = i - variableStart\r\n        break\r\n      }\r\n    }\r\n\r\n    image.description =\r\n      variableLength === 0 ? null : getString(dv, variableLength, variableStart)\r\n    image.data = buffer.slice(variableStart + 1)\r\n\r\n    result.value = image\r\n  }\r\n\r\n  return result.tag ? result : null\r\n}\r\n\r\n/**\r\n * Parses a given buffer into an ID3 frame\r\n * @param {ArrayBuffer} buffer Buffer to read data from\r\n * @param {number} major Major version of ID3\r\n * @param {number} minor Minor version of ID3\r\n * @return {ID3Frame|null}\r\n */\r\nexport function parse(\r\n  buffer: ArrayBuffer,\r\n  major: number,\r\n  minor: number\r\n): ID3Frame | null {\r\n  minor = minor || 0\r\n  major = major || 4\r\n\r\n  const result: ID3Frame = { id: null, tag: null, value: null }\r\n  const dv = new DataView(buffer)\r\n\r\n  if (major < 3) {\r\n    return parseLegacy(buffer)\r\n  }\r\n\r\n  const header = {\r\n    id: getString(dv, 4),\r\n    type: getString(dv, 1),\r\n    size: getUint32Synch(dv, 4),\r\n    flags: [dv.getUint8(8), dv.getUint8(9)]\r\n  }\r\n\r\n  /*\r\n   * No support for compressed, unsychronised, etc frames\r\n   */\r\n  if (header.flags[1] !== 0) {\r\n    return null\r\n  }\r\n\r\n  const matchedType = types.get(header.id)\r\n\r\n  if (!matchedType) {\r\n    return null\r\n  }\r\n\r\n  result.tag = matchedType\r\n  result.id = header.id\r\n\r\n  if (header.type === 'T') {\r\n    const encoding = dv.getUint8(10)\r\n    let val: string | null = null\r\n\r\n    /*\r\n     * TODO: Implement UTF-8, UTF-16 and UTF-16 with BOM properly?\r\n     */\r\n    if (encoding === 0 || encoding === 3) {\r\n      val = getString(dv, -11, 11)\r\n    } else if (encoding === 1) {\r\n      val = getStringUtf16(dv, -11, 11, true)\r\n    } else if (encoding === 2) {\r\n      val = getStringUtf16(dv, -11, 11)\r\n    }\r\n\r\n    if (header.id === 'TCON' && val !== null && !!parseInt(val)) {\r\n      val = genres[parseInt(val)]\r\n    }\r\n\r\n    result.value = val\r\n  } else if (header.type === 'W') {\r\n    result.value = getString(dv, -10, 10)\r\n  } else if (header.id === 'PRIV') {\r\n    const variableStart = 10\r\n    let variableLength = 0\r\n\r\n    for (let i = 0; ; i++) {\r\n      if (dv.getUint8(i) === 0x00) {\r\n        variableLength = i - variableStart\r\n        break\r\n      }\r\n    }\r\n\r\n    result.value = {\r\n      identifier:\r\n        variableLength === 0\r\n          ? null\r\n          : getString(dv, variableLength, variableStart),\r\n      data: buffer.slice(variableLength + variableStart + 1)\r\n    }\r\n  } else if (header.id === 'COMM') {\r\n    /*\r\n     * TODO: Implement UTF-8, UTF-16 and UTF-16 with BOM properly?\r\n     */\r\n    const encoding = dv.getUint8(10)\r\n    let variableStart = 14\r\n\r\n    /*\r\n     * Skip the comment description and retrieve only the comment its self\r\n     */\r\n    for (let i = variableStart; ; i++) {\r\n      if (encoding === 1 || encoding === 2) {\r\n        if (dv.getUint16(i) === 0x0000) {\r\n          variableStart = i + 2\r\n          break\r\n        }\r\n        i++\r\n      } else {\r\n        if (dv.getUint8(i) === 0x00) {\r\n          variableStart = i + 1\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    if (encoding === 0 || encoding === 3) {\r\n      result.value = getString(dv, -1 * variableStart, variableStart)\r\n    } else if (encoding === 1) {\r\n      result.value = getStringUtf16(dv, -1 * variableStart, variableStart, true)\r\n    } else if (encoding === 2) {\r\n      result.value = getStringUtf16(dv, -1 * variableStart, variableStart)\r\n    }\r\n  } else if (header.id === 'APIC') {\r\n    const encoding = dv.getUint8(10)\r\n    const image: ImageValue = {\r\n      type: null,\r\n      mime: null,\r\n      description: null,\r\n      data: null\r\n    }\r\n    let variableStart = 11\r\n    let variableLength = 0\r\n\r\n    for (let i = variableStart; ; i++) {\r\n      if (dv.getUint8(i) === 0x00) {\r\n        variableLength = i - variableStart\r\n        break\r\n      }\r\n    }\r\n\r\n    image.mime = getString(dv, variableLength, variableStart)\r\n    image.type =\r\n      imageTypes[dv.getUint8(variableStart + variableLength + 1)] || 'other'\r\n    variableStart += variableLength + 2\r\n    variableLength = 0\r\n\r\n    for (let i = variableStart; ; i++) {\r\n      if (dv.getUint8(i) === 0x00) {\r\n        variableLength = i - variableStart\r\n        break\r\n      }\r\n    }\r\n\r\n    if (variableLength !== 0) {\r\n      if (encoding === 0 || encoding === 3) {\r\n        image.description = getString(dv, variableLength, variableStart)\r\n      } else if (encoding === 1) {\r\n        image.description = getStringUtf16(\r\n          dv,\r\n          variableLength,\r\n          variableStart,\r\n          true\r\n        )\r\n      } else if (encoding === 2) {\r\n        image.description = getStringUtf16(dv, variableLength, variableStart)\r\n      }\r\n    }\r\n\r\n    image.data = buffer.slice(variableStart + 1)\r\n\r\n    result.value = image\r\n  }\r\n\r\n  return result.tag ? result : null\r\n}\r\n","import Reader from '@/lib/id3/reader'\r\nimport { parse as parseFrame, ID3Frame, ImageValue } from '@/lib/id3/id3-frame'\r\nimport { getString, getUint32Synch, getUint24 } from '@/lib/id3/utils'\r\nimport genres from '@/lib/id3/genres'\r\n\r\nexport interface ID3Tag {\r\n  title: string | null\r\n  album: string | null\r\n  artist: string | null\r\n  year: string | null\r\n  [key: string]: any\r\n}\r\n\r\nexport interface ID3TagV1 extends ID3Tag {\r\n  kind: 'v1'\r\n  comment: string | null\r\n  track: string | null\r\n  genre: string | null\r\n  version: number\r\n}\r\n\r\nexport interface ID3TagV2 extends ID3Tag {\r\n  kind: 'v2'\r\n  version: [number, number]\r\n  frames: ID3Frame[]\r\n  images: ImageValue[]\r\n}\r\n\r\n// parses a given resource into an ID3 tag\r\nexport async function parse(handle: Reader): Promise<ID3Tag | null> {\r\n  let tag: ID3Tag | null = null\r\n\r\n  /*\r\n   * Read the last 128 bytes (ID3v1)\r\n   */\r\n  const v1HeaderBuf = await handle.read(128, handle.size - 128)\r\n  const v1Header = new DataView(v1HeaderBuf)\r\n\r\n  if (\r\n    v1HeaderBuf.byteLength === 128 &&\r\n    getString(v1Header, 3, undefined, true) === 'TAG'\r\n  ) {\r\n    tag = {\r\n      kind: 'v1',\r\n      title: getString(v1Header, 30, 3).trim() || null,\r\n      album: getString(v1Header, 30, 63).trim() || null,\r\n      artist: getString(v1Header, 30, 33).trim() || null,\r\n      year: getString(v1Header, 4, 93).trim() || null,\r\n      genre: null,\r\n      comment: null,\r\n      track: null\r\n    }\r\n\r\n    /*\r\n     * If there is a zero byte at [125], the comment is 28 bytes and the\r\n     * remaining 2 are [0, trackno]\r\n     */\r\n    if (v1Header.getUint8(125) === 0) {\r\n      tag.comment = getString(v1Header, 28, 97)\r\n      tag.version = 1.1\r\n      tag.track = v1Header.getUint8(126)\r\n    } else {\r\n      tag.comment = getString(v1Header, 30, 97)\r\n    }\r\n\r\n    /*\r\n     * Lookup the genre index in the predefined genres array\r\n     */\r\n    tag.genre = genres[v1Header.getUint8(127)] || null\r\n  }\r\n\r\n  /*\r\n   * Read 14 bytes (10 for ID3v2 header, 4 for possible extended header size)\r\n   * Assuming the ID3v2 tag is prepended\r\n   */\r\n  const v2PrefixBuf = await handle.read(14, 0)\r\n  const v2Prefix = new DataView(v2PrefixBuf)\r\n\r\n  /*\r\n   * Be sure that the buffer is at least the size of an id3v2 header\r\n   * Assume incompatibility if a major version of > 4 is used\r\n   */\r\n  if (\r\n    v2PrefixBuf.byteLength === 14 &&\r\n    getString(v2Prefix, 3, undefined, true) === 'ID3' &&\r\n    v2Prefix.getUint8(3) <= 4\r\n  ) {\r\n    let headerSize = 10\r\n    let tagSize = 0\r\n    const version = [v2Prefix.getUint8(3), v2Prefix.getUint8(4)]\r\n    const tagFlags = v2Prefix.getUint8(5)\r\n\r\n    /*\r\n     * Do not support unsynchronisation\r\n     */\r\n    if ((tagFlags & 0x80) === 0) {\r\n      tag = {\r\n        kind: 'v2',\r\n        title: tag ? tag.title : null,\r\n        album: tag ? tag.album : null,\r\n        artist: tag ? tag.artist : null,\r\n        year: tag ? tag.year : null,\r\n        version: version,\r\n        frames: [],\r\n        images: []\r\n      }\r\n\r\n      /*\r\n       * Increment the header size to offset by if an extended header exists\r\n       */\r\n      if ((tagFlags & 0x40) !== 0) {\r\n        headerSize += getUint32Synch(v2Prefix, 11)\r\n      }\r\n\r\n      /*\r\n       * Calculate the tag size to be read\r\n       */\r\n      tagSize += getUint32Synch(v2Prefix, 6)\r\n\r\n      const v2TagBuf = await handle.read(tagSize, headerSize)\r\n      const v2Tag = new DataView(v2TagBuf)\r\n      let position = 0\r\n\r\n      while (position < v2TagBuf.byteLength) {\r\n        let slice\r\n        let isFrame = true\r\n\r\n        for (let i = 0; i < 3; i++) {\r\n          const frameBit = v2Tag.getUint8(position + i)\r\n\r\n          if (\r\n            (frameBit < 0x41 || frameBit > 0x5a) &&\r\n            (frameBit < 0x30 || frameBit > 0x39)\r\n          ) {\r\n            isFrame = false\r\n          }\r\n        }\r\n\r\n        if (!isFrame) {\r\n          break\r\n        }\r\n\r\n        /*\r\n         * < v2.3, frame ID is 3 chars, size is 3 bytes making a total\r\n         * size of 6 bytes.\r\n         * >= v2.3, frame ID is 4 chars, size is 4 bytes, flags are 2 bytes,\r\n         * total 10 bytes.\r\n         */\r\n        if (version[0] < 3) {\r\n          slice = v2TagBuf.slice(\r\n            position,\r\n            position + 6 + getUint24(v2Tag, position + 3)\r\n          )\r\n        } else if (version[0] === 3) {\r\n          slice = v2TagBuf.slice(\r\n            position,\r\n            position + 10 + v2Tag.getUint32(position + 4)\r\n          )\r\n        } else {\r\n          slice = v2TagBuf.slice(\r\n            position,\r\n            position + 10 + getUint32Synch(v2Tag, position + 4)\r\n          )\r\n        }\r\n\r\n        const frame = await parseFrame(slice, version[0], version[1])\r\n\r\n        if (frame && frame.tag) {\r\n          const tagAsV2 = tag as ID3TagV2\r\n\r\n          tagAsV2.frames.push(frame)\r\n\r\n          if (frame.tag === 'image') {\r\n            tagAsV2.images.push(frame.value as ImageValue)\r\n          } else {\r\n            tag[frame.tag] = frame.value\r\n          }\r\n        }\r\n\r\n        position += slice.byteLength\r\n      }\r\n    }\r\n  }\r\n  return tag\r\n}\r\n","/*\r\n  Copy in https://github.com/43081j/id3\r\n  Author: James Garbutt\r\n */\r\n\r\n\r\nimport Reader from '@/lib/id3/reader'\r\nimport RemoteReader from '@/lib/id3/remote-reader'\r\nimport { parse } from '@/lib/id3/id3-tag'\r\n\r\nexport async function fromReader(reader: Reader) {\r\n  await reader.open()\r\n  const tags = await parse(reader)\r\n  await reader.close()\r\n  return tags\r\n}\r\n\r\nexport default async function load(url: string) {\r\n  return fromReader(new RemoteReader(url))\r\n}\r\n","require('./_typed-array')('Uint16', 2, function (init) {\n  return function Uint16Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n"],"sourceRoot":""}